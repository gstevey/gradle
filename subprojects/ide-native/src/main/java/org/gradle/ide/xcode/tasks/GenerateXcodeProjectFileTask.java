/*
 * Copyright 2017 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.gradle.ide.xcode.tasks;

import com.dd.plist.NSDictionary;
import com.facebook.buck.apple.xcode.GidGenerator;
import com.facebook.buck.apple.xcode.XcodeprojSerializer;
import com.facebook.buck.apple.xcode.xcodeproj.PBXBuildFile;
import com.facebook.buck.apple.xcode.xcodeproj.PBXFileReference;
import com.facebook.buck.apple.xcode.xcodeproj.PBXLegacyTarget;
import com.facebook.buck.apple.xcode.xcodeproj.PBXNativeTarget;
import com.facebook.buck.apple.xcode.xcodeproj.PBXProject;
import com.facebook.buck.apple.xcode.xcodeproj.PBXReference;
import com.facebook.buck.apple.xcode.xcodeproj.PBXSourcesBuildPhase;
import com.facebook.buck.apple.xcode.xcodeproj.PBXTarget;
import com.facebook.buck.apple.xcode.xcodeproj.XCBuildConfiguration;
import com.google.common.base.Optional;
import org.gradle.api.DefaultTask;
import org.gradle.api.file.ConfigurableFileTree;
import org.gradle.api.tasks.TaskAction;
import org.gradle.internal.UncheckedException;

import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.io.Writer;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class GenerateXcodeProjectFileTask extends DefaultTask {
    @TaskAction
    void generate() {
        // TODO - this task should really only merge the in-memory model generated by a task inside each project
        PBXProject project = new PBXProject(getProject().getName());

        // Required for making think the project isn't corrupted...
        // TODO - create according to buildTypes container
        XCBuildConfiguration c = project.getBuildConfigurationList().getBuildConfigurationsByName().getUnchecked("Debug");
        c.setBuildSettings(new NSDictionary());


        ConfigurableFileTree sources = getProject().fileTree("src/main/swift");
        List<PBXReference> fileReferences = new ArrayList<PBXReference>();
        for (File source : sources.getFiles()) {
            PBXFileReference fileReference = new PBXFileReference(source.getName(), source.getAbsolutePath(), PBXReference.SourceTree.ABSOLUTE);
            fileReferences.add(fileReference);
            project.getMainGroup().getChildren().add(fileReference);
        }
        if (getProject().getBuildFile().exists()) {
            project.getMainGroup().getChildren().add(new PBXFileReference(getProject().getBuildFile().getName(), getProject().getBuildFile().getAbsolutePath(), PBXReference.SourceTree.ABSOLUTE));
        }

        // TODO - create a target per component
        PBXTarget index_target11 = createIndexingTarget("[indexing] DO NOT BUILD target11", getProject().getName(), fileReferences);
        project.getTargets().add(index_target11);
        PBXTarget target11 = createTarget("target11", getProject().getName(), ":linkMain");
        project.getTargets().add(target11);

        PBXFileReference f = new PBXFileReference(getProject().getName(), getProject().file("build/exe/app").getAbsolutePath(), PBXReference.SourceTree.ABSOLUTE);
        f.setExplicitFileType(Optional.of("compiled.mach-o.executable"));
        project.getMainGroup().getOrCreateChildGroupByName("Products").getChildren().add(f);

        // Serialize the model
        // TODO - Write the pipeworks to use GeneratorTask
        XcodeprojSerializer serializer = new XcodeprojSerializer(new GidGenerator(Collections.<String>emptySet()), project);
        NSDictionary rootObject = serializer.toPlist();
        File xcodeprojDir = getProject().file(getProject().getName() + ".xcodeproj");
        xcodeprojDir.mkdirs();
        File outputFile = new File(xcodeprojDir, "project.pbxproj");

        // TODO - Use GeneratorTask since this is the same code as AbstractPersitableConfigurationObject
        try {
            Writer writer = new OutputStreamWriter(new BufferedOutputStream(new FileOutputStream(outputFile)), "UTF-8");
            try {
                String content = rootObject.toASCIIPropertyList();
                writer.write(content);
                writer.flush();
            } finally {
                writer.close();
            }
        } catch (IOException e) {
            throw UncheckedException.throwAsUncheckedException(e);
        }

        new File(xcodeprojDir, "xcshareddata/xcschemes").mkdirs();
        try {
            Writer writer = new OutputStreamWriter(new BufferedOutputStream(new FileOutputStream(new File(xcodeprojDir, "xcshareddata/xcschemes/target11.xcscheme"))), "UTF-8");
            try {
                String content = targetXcshemeContentNotIndex("target11", target11.getGlobalID(), getProject().getName() + ".xcodeproj", getProject().file("build/exe/app").getAbsolutePath());
                writer.write(content);
                writer.flush();
            } finally {
                writer.close();
            }
        } catch (IOException e) {
            throw UncheckedException.throwAsUncheckedException(e);
        }

        try {
            Writer writer = new OutputStreamWriter(new BufferedOutputStream(new FileOutputStream(new File(xcodeprojDir, "xcshareddata/xcschemes/[indexing] DO NOT BUILD target11.xcscheme"))), "UTF-8");
            try {
                String content = targetXcshemeContent("[indexing] DO NOT BUILD target11", index_target11.getGlobalID(), getProject().getName() + "xcodeproj", "");
                writer.write(content);
                writer.flush();
            } finally {
                writer.close();
            }
        } catch (IOException e) {
            throw UncheckedException.throwAsUncheckedException(e);
        }
    }

    private String targetXcshemeContentNotIndex(String targetName, String id, String projectFilename, String executablePath) {
        return "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n" +
            "<Scheme\n" +
            "   LastUpgradeVersion = \"0830\"\n" +
            "   version = \"1.3\">\n" +
            "   <BuildAction\n" +
            "      parallelizeBuildables = \"YES\"\n" +
            "      buildImplicitDependencies = \"YES\">\n" +
            "      <BuildActionEntries>\n" +
            "         <BuildActionEntry\n" +
            "            buildForTesting = \"YES\"\n" +
            "            buildForRunning = \"YES\"\n" +
            "            buildForProfiling = \"YES\"\n" +
            "            buildForArchiving = \"YES\"\n" +
            "            buildForAnalyzing = \"YES\">\n" +
            "            <BuildableReference\n" +
            "               BuildableIdentifier = \"primary\"\n" +
            "               BlueprintIdentifier = \"" + id + "\"\n" +
            "               BuildableName = \"" + targetName + "\"\n" +
            "               BlueprintName = \"" + targetName + "\"\n" +
            "               ReferencedContainer = \"container:" + projectFilename + "\">\n" +
            "            </BuildableReference>\n" +
            "         </BuildActionEntry>\n" +
            "      </BuildActionEntries>\n" +
            "   </BuildAction>\n" +
            "   <TestAction\n" +
            "      buildConfiguration = \"Debug\"\n" +
            "      selectedDebuggerIdentifier = \"Xcode.DebuggerFoundation.Debugger.LLDB\"\n" +
            "      selectedLauncherIdentifier = \"Xcode.DebuggerFoundation.Launcher.LLDB\"\n" +
            "      shouldUseLaunchSchemeArgsEnv = \"YES\">\n" +
            "      <Testables>\n" +
            "      </Testables>\n" +
            "      <AdditionalOptions>\n" +
            "      </AdditionalOptions>\n" +
            "   </TestAction>\n" +
            "   <LaunchAction\n" +
            "      buildConfiguration = \"Debug\"\n" +
            "      selectedDebuggerIdentifier = \"Xcode.DebuggerFoundation.Debugger.LLDB\"\n" +
            "      selectedLauncherIdentifier = \"Xcode.DebuggerFoundation.Launcher.LLDB\"\n" +
            "      launchStyle = \"0\"\n" +
            "      useCustomWorkingDirectory = \"NO\"\n" +
            "      ignoresPersistentStateOnLaunch = \"NO\"\n" +
            "      debugDocumentVersioning = \"YES\"\n" +
            "      debugServiceExtension = \"internal\"\n" +
            "      allowLocationSimulation = \"YES\">\n" +
            "      <PathRunnable\n" +
            "         runnableDebuggingMode = \"0\"\n" +
            "         FilePath = \"" + executablePath + "\">\n" +
            "      </PathRunnable>\n" +
            "      <AdditionalOptions>\n" +
            "      </AdditionalOptions>\n" +
            "   </LaunchAction>\n" +
            "   <ProfileAction\n" +
            "      buildConfiguration = \"Debug\"\n" +
            "      shouldUseLaunchSchemeArgsEnv = \"YES\"\n" +
            "      savedToolIdentifier = \"\"\n" +
            "      useCustomWorkingDirectory = \"NO\"\n" +
            "      debugDocumentVersioning = \"YES\">\n" +
            "   </ProfileAction>\n" +
            "   <AnalyzeAction\n" +
            "      buildConfiguration = \"Debug\">\n" +
            "   </AnalyzeAction>\n" +
            "   <ArchiveAction\n" +
            "      buildConfiguration = \"Debug\"\n" +
            "      revealArchiveInOrganizer = \"YES\">\n" +
            "   </ArchiveAction>\n" +
            "</Scheme>";
    }

    private String targetXcshemeContent(String targetName, String id, String projectFilename, String executablePath) {
        return "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n" +
            "<Scheme\n" +
            "   LastUpgradeVersion = \"0830\"\n" +
            "   version = \"1.3\">\n" +
            "   <BuildAction\n" +
            "      parallelizeBuildables = \"YES\"\n" +
            "      buildImplicitDependencies = \"YES\">\n" +
            "      <BuildActionEntries>\n" +
            "         <BuildActionEntry\n" +
            "            buildForTesting = \"YES\"\n" +
            "            buildForRunning = \"YES\"\n" +
            "            buildForProfiling = \"YES\"\n" +
            "            buildForArchiving = \"YES\"\n" +
            "            buildForAnalyzing = \"YES\">\n" +
            "            <BuildableReference\n" +
            "               BuildableIdentifier = \"primary\"\n" +
            "               BlueprintIdentifier = \"" + id + "\"\n" +
            "               BuildableName = \"" + targetName + "\"\n" +
            "               BlueprintName = \"" + targetName + "\"\n" +
            "               ReferencedContainer = \"container:" + projectFilename + "\">\n" +
            "            </BuildableReference>\n" +
            "         </BuildActionEntry>\n" +
            "      </BuildActionEntries>\n" +
            "   </BuildAction>\n" +
            "   <TestAction\n" +
            "      buildConfiguration = \"Debug\"\n" +
            "      selectedDebuggerIdentifier = \"Xcode.DebuggerFoundation.Debugger.LLDB\"\n" +
            "      selectedLauncherIdentifier = \"Xcode.DebuggerFoundation.Launcher.LLDB\"\n" +
            "      shouldUseLaunchSchemeArgsEnv = \"YES\">\n" +
            "      <Testables>\n" +
            "      </Testables>\n" +
            "      <AdditionalOptions>\n" +
            "      </AdditionalOptions>\n" +
            "   </TestAction>\n" +
            "   <LaunchAction\n" +
            "      buildConfiguration = \"Debug\"\n" +
            "      selectedDebuggerIdentifier = \"Xcode.DebuggerFoundation.Debugger.LLDB\"\n" +
            "      selectedLauncherIdentifier = \"Xcode.DebuggerFoundation.Launcher.LLDB\"\n" +
            "      launchStyle = \"0\"\n" +
            "      useCustomWorkingDirectory = \"NO\"\n" +
            "      ignoresPersistentStateOnLaunch = \"NO\"\n" +
            "      debugDocumentVersioning = \"YES\"\n" +
            "      debugServiceExtension = \"internal\"\n" +
            "      allowLocationSimulation = \"YES\">\n" +
            "      <PathRunnable\n" +
            "         runnableDebuggingMode = \"0\"\n" +
            "         FilePath = \"" + executablePath + "\">\n" +
            "      </PathRunnable>\n" +
            "      <MacroExpansion>\n" +
            "         <BuildableReference\n" +
            "            BuildableIdentifier = \"primary\"\n" +
            "            BlueprintIdentifier = \"" + id + "\"\n" +
            "            BuildableName = \"" + targetName + "\"\n" +
            "            BlueprintName = \"" + targetName + "\"\n" +
            "            ReferencedContainer = \"container:" + projectFilename + "\">\n" +
            "         </BuildableReference>\n" +
            "      </MacroExpansion>\n" +
            "      <AdditionalOptions>\n" +
            "      </AdditionalOptions>\n" +
            "   </LaunchAction>\n" +
            "   <ProfileAction\n" +
            "      buildConfiguration = \"Debug\"\n" +
            "      shouldUseLaunchSchemeArgsEnv = \"YES\"\n" +
            "      savedToolIdentifier = \"\"\n" +
            "      useCustomWorkingDirectory = \"NO\"\n" +
            "      debugDocumentVersioning = \"YES\">\n" +
            "      <MacroExpansion>\n" +
            "         <BuildableReference\n" +
            "            BuildableIdentifier = \"primary\"\n" +
            "            BlueprintIdentifier = \"" + id + "\"\n" +
            "            BuildableName = \"" + targetName + "\"\n" +
            "            BlueprintName = \"" + targetName + "\"\n" +
            "            ReferencedContainer = \"container:" + projectFilename + "\">\n" +
            "         </BuildableReference>\n" +
            "      </MacroExpansion>\n" +
            "   </ProfileAction>\n" +
            "   <AnalyzeAction\n" +
            "      buildConfiguration = \"Debug\">\n" +
            "   </AnalyzeAction>\n" +
            "   <ArchiveAction\n" +
            "      buildConfiguration = \"Debug\"\n" +
            "      revealArchiveInOrganizer = \"YES\">\n" +
            "   </ArchiveAction>\n" +
            "</Scheme>";
    }

    /**
     *
     * @param name name of the component (project)
     * @param productName the baseName of a component
     * @param taskName should be the lifecycle task of the binary to build
     * @return
     */
    private PBXLegacyTarget createTarget(String name, String productName, String taskName) {
        PBXLegacyTarget target = new PBXLegacyTarget(name, PBXTarget.ProductType.TOOL);
        target.setProductName(productName);
        NSDictionary buildSettings = new NSDictionary();
        target.getBuildConfigurationList().getBuildConfigurationsByName().getUnchecked("Debug").setBuildSettings(buildSettings);

        if (getProject().file("gradlew").exists()) {
            target.setBuildToolPath(getProject().file("gradlew").getAbsolutePath());
        } else {
            // TODO - default to gradle on the path (or should we generate an error if no gradle is in the path?)
            target.setBuildToolPath("/Users/daniel/gradle/gradle-source-build/bin/gradle");
        }
        target.setBuildArgumentsString(taskName);

        return target;
    }

    private PBXNativeTarget createIndexingTarget(String name, String productName, List<PBXReference> fileReferences) {
        PBXSourcesBuildPhase p = new PBXSourcesBuildPhase();
        for (PBXReference fileReference : fileReferences) {
            p.getFiles().add(new PBXBuildFile(fileReference));
        }

        PBXNativeTarget target = new PBXNativeTarget(name, PBXTarget.ProductType.TOOL);
        NSDictionary buildSettings = new NSDictionary();
        buildSettings.put("SWIFT_VERSION", "3.0");  // TODO - Choose the right version for swift
        buildSettings.put("PRODUCT_NAME", productName);  // Mandatory
        target.getBuildConfigurationList().getBuildConfigurationsByName().getUnchecked("Debug").setBuildSettings(buildSettings);
        target.getBuildPhases().add(p);

        return target;
    }
}
